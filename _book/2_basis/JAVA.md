# JAVA


本章内容梗概：

- [抽象类与接口](#抽象类与接口)
- [泛型](#泛型)
- [设计模式](#设计模式)

## <a id="抽象类与接口">抽象类与接口</a>

**一、抽象类的特点** 

- 使用extends 关键字
- 抽象类是由子类具有相同的一类特征抽象而来，也可以说是其基类或父类
- 抽象方法必须为public或protected，默认为public
- 抽象类不能用来创建对象
- 抽象方法必须由子类来实现
- 如果一个类继承于一个抽象类，则子类必须实现父类的抽象方法；如果子类没有实现父类的抽象方法，则必须将子类也定义为抽象类

**二、接口的特点** 

- 使用implements关键字
- 接口中所有方法访问权限自动被声明为public
- 实现接口的非抽象类必须实现接口中所有方法
- 接口不能创建对象，但可以声明一个接口变量，方便调用
- Java为保证数据安全性不支持多继承，一个类只能有一个父类但可以同时实现多个接口，弥补了抽象类不能多继承的缺陷

**三、抽象类和接口区别**

1. 抽象层次不同  
   抽象类是对整个类整体进行抽象，包括属性、行为；接口对类局部行为进行抽象

2. 跨域不同  
   抽象类所跨域的是具有相似特点的类；接口可以跨域不同的类

   抽象类体现继承关系，考虑的是子类和父类“是不是”同一类的关系；接口不要求实现的类与接口是同一本质，它们之间只存在“有没有这个能力”的关系

3. 设计层次不同  
   抽象类是自下而上的设计，在子类中重复出现的工作，抽象到抽象类中；接口是自上而下，定义行为和规范

## <a id="泛型">泛型</a>

**一、什么是泛型**

泛型的本质是为了参数化类型，即在不创建类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型。

泛型在使用的过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口、方法中，分别被称为泛型类、泛型接口、泛型方法。

举个例子，用JAVA创建List的时候，我们会使用

```java
List<Integer> list = new ArrayList<Integer>();
```

这里的ArrayList就是一个泛型类，通过设定<>中不同的类型，可以往集合里面存储不同类型的数据类型（只能存储泛型类设定的数据类型）

## <a id="设计模式">设计模式</a>
**一、单例模式（创建型模式）**

单例类只能有一个实例；单例类必须自己创建自己的唯一实例；单例类必须给所有其他对象提供这一实例

- 目的：保证一个类仅有一个实例，并提供一个访问它的全局访问点
- 主要解决：一个全局使用的类频繁地创建与销毁问题
- 优点：内存中只有一个实例，节省系统资源，尤其是频繁创建和销毁实例；避免对资源的多重占用
- 缺点：没有接口，不能继承，与类的单一职责原则冲突（一个类只应该关心内部逻辑而不关心外部如何实例化）

**二、观察者模式（行为型模式）**

对象间存在一对多关系

- 目的：当一个对象被修改时，则会自动通知它的依赖对象
- 主要解决：一个对象状态改变给其他对象通知的问题，且要考虑易用和低耦合，保证高度的协作
- 优点：观察者和被观察者是依赖的（紧耦合）
- 缺点：观察者仅能知道目标对象发生了变化，而不知道是怎么发生变化的；如果观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能会导致系统崩溃；被观察对象如果有很多直接或间接的观察者的话，将所有观察者都通知到会花费很多时间

**三、发布-订阅模式（广义上的观察者模式）**

发布者和订阅者不知道对方的存在，需要一个第三方组件，即信息中介将订阅者和发布者串联起来，它过滤和分配所有输入的消息

**四、发布-订阅模式与观察者模式的区别**

1. 观察者模式中，observer知道subject的存在，subject一直保持对观察者进行记录；发布-订阅模式中，publisher和subscriber不知道对方的存在，它们只有通过消息代理进行通信

2. 观察者模式中，组件是紧耦合的；发布订阅模式中，组件是松散耦合的

3. 观察者模式大多数时候是同步的，比如当事件触发，subject就会去调用观察者的方法；发布-订阅模式大多数时候是异步的（使用消息队列）

![](\Images\设计模式.jpg)