# 数据结构与算法

常见排序算法的时间复杂度要熟悉，尤其是归并和快排，因为会让你手敲代码，敲完后很可能会顺势问问你时间空间复杂度。

树相关的内容前端里大概不怎么涉及，不过因为树是一种很重要的数据结构，还是放进来吧。
- [排序算法](#排序算法)
- [动态查找树比较](#动态查找树比较)

## <a id="排序算法">排序算法</a>

先来看下常见排序算法的分类：

<img src="\Images\排序算法分类.jpg" style="zoom:80%;" />

- **比较类排序**：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。

- **非比较类排序**：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。

**1、冒泡排序（Bubble Sort）**  
冒泡排序是一种简单的排序算法，通过一趟又一趟地比较数组中的每一个元素，使较大的数据下沉，较小的数据上升。

**2、选择排序（Selection Sort）**  
首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。

**3、插入排序（Insertion Sort）**  
通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。

**4、希尔排序（Shell Sort）**  
希尔排序是简单插入排序的改进版，通过将数据分成不同的组，先对每一组进行排序，然后再对所有的元素进行一次插入排序，以减少数据交换和移动的次数。

**5、归并排序（Merge Sort）**  
归并排序的核心思想是分而治之（Divide and Conquer）：将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并。

**6、快速排序（Quick Sort）**  
通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

**7、堆排序（Heap Sort）**  
堆排序是指利用堆这种数据结构所设计的一种排序算法。堆排序会将所有的数据建成一个堆，最大的数据在堆顶，然后将堆顶数据和序列的最后一个数据交换。接下来再次重建堆，交换数据，依次下去，就可以排序所有的数据。

**8、计数排序（Counting Sort）**  
计数排序核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。

**9、桶排序（Bucket Sort）**  
桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。

**10、基数排序（Radix Sort）**  
基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。

最后，附上算法复杂度的比较表：

![](\Images\排序算法比较.jpg)

- **稳定**：a原本在b前面且a=b，排序之后a仍然在b的前面。
- **不稳定**：a原本在b的前面且a=b，排序之后 a 可能会出现在 b 的后面。

注：n小时，冒泡排序、交换排序、选择排序比较适用；n大时，快速排序、归并排序、堆排序比较适用；对于大部分已排序好的数列，插入排序比较适用。



参考：[十大经典排序算法（动图演示）](https://www.cnblogs.com/onepixel/p/7674659.html)	[排序算法比较·面试宝典](https://troywu0.gitbooks.io/spark/content/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83.html)

## <a id="动态查找树比较">动态查找树比较</a>
动态查找树主要有：二叉查找树、平衡二叉查找树、红黑树、B树，它们的特点是：

1. 都是动态结构。在删除，插入操作的时候，都不需要彻底重建原始的索引树。最多就是执行一定量的旋转，变色操作来有限的改变树的形态。而这些操作所付出的代价都远远小于重建一棵树。
2. 查找的时间复杂度大体维持在O(logN)数量级上。可能有些结构在最差的情况下效率将会下降很快，比如BST。

**1、二叉查找树（Binary Search Tree，BST)** 

二叉查找树的发现完全是因为静态查找结构在动态插入、删除结点时需要付出很大代价。

- BST 的操作代价分析：

  1. 查找代价  
任何一个数据的查找过程都需要从根结点出发，沿某一个路径朝叶子结点前进。因此查找中数据比较次数与树的形态密切相关。  
     当树中每个结点左右子树高度大致相同时，树高为logN。则平均查找长度与logN成正比，查找的平均时间复杂度在O(logN)数量级上。  
当先后插入的关键字有序时，BST退化成单支树结构。此时树高n。平均查找长度为(n+1)\/2，查找的平均时间复杂度在O(N)数量级上。
  2. 插入代价  
   新结点插入到叶子结点时完全不需要改变树中原有结点的组织结构。插入一个结点的代价与查找一个不存在的数据的代价完全相同。
  3. 删除代价  
   当删除一个结点P，首先需要定位到这个结点P，这个过程需要一个查找的代价。然后稍微改变一下树的形态。如果被删除结点的左、右子树只有一个存在，则改变形态的代价仅为O(1)。如果被删除结点的左、右子树均存在，只需要将当P的左孩子的右孩子的右孩子的...的右叶子结点与P互换，在改变一些左右子树即可。因此删除操作的时间复杂度最大不会超过O(logN)。

- BST效率总结 : 

  查找最好时间复杂度O(logN)，最坏时间复杂度O(N)；插入删除操作算法简单，时间复杂度与查找差不多。

**2、平衡二叉查找树（Balanced Binary Search Tree/AVL)** 

二叉查找树在最差情况下和顺序查找效率相当，这是无法接受的。事实也证明，当存储数据足够大的时候，树的结构对某些关键字的查找效率影响很大。当然，造成这种情况的主要原因就是BST不够平衡(左右子树高度差太大)。既然如此，那么我们就需要通过一定的算法，将不平衡树改变成平衡树。因此，AVL树就诞生了。

- AVL 的操作代价分析：

  1. 查找代价  
     AVL是严格平衡的BST（平衡因子不超过1）。那么查找过程与BST一样，只是AVL不会出现最差情况的BST(单支树)。因此查找效率最好，最坏情况都是O(logN)数量级的。
  2. 插入代价  
     AVL必须要保证严格平衡(|bf|<=1)，那么每一次插入数据使得AVL中某些结点的平衡因子超过1就必须进行旋转操作。事实上，AVL的每一次插入结点操作最多只需要旋转1次(单旋转或双旋转)。因此，总体上插入操作的代价仍然在O(logN)级别上(插入结点需要首先查找插入的位置)。
  3. 删除代价  
     AVL删除结点的算法可以参见BST的删除结点，但是删除之后必须检查从删除结点开始到根结点路径上的所有结点的平衡因子，因此删除的代价稍微要大一些。每一次删除操作最多需要O(logN)次旋转。所以，删除操作的时间复杂度为O(logN)+O(logN)=O(2logN)

- AVL效率总结 : 

  查找的时间复杂度维持在O(logN)，不会出现最差情况；AVL树在执行每个插入操作时最多需要1次旋转，其时间复杂度在O(logN)左右；AVL树在执行删除时代价稍大，执行每个删除操作的时间复杂度需要O(2logN)。

**3、红黑树（Red-Black Tree，RBT）**

二叉平衡树的严格平衡策略以牺牲建立查找结构(插入，删除操作)的代价，换来了稳定的O(logN) 的查找时间复杂度。而红黑树是一种折中策略，即不牺牲太大的建立查找结构的代价，也能保证稳定高效的查找效率呢。

- RBT 的操作代价分析：

  1. 查找代价  
     由于红黑树的性质(最长路径长度不超过最短路径长度的2倍)，可以说明红黑树虽然不像AVL一样是严格平衡的，但平衡性能还是要比BST要好。其查找代价基本维持在O(logN)左右，但在最差情况下(最长路径是最短路径的2倍少1)，比AVL要略逊色一点。
  2. 插入代价  
     RBT插入结点时，需要旋转操作和变色操作。但由于只需要保证RBT基本平衡就可以了。因此插入结点最多只需要2次旋转，这一点和AVL的插入操作一样。虽然变色操作需要O(logN)，但是变色操作十分简单，代价很小。
  3. 删除代价  
     RBT的删除操作代价要比AVL要好的多，删除一个结点最多只需要3次旋转操作。

- RBT效率总结 : 

  查找 效率最好情况下时间复杂度为O(logN)，但在最坏情况下比AVL要差一些，但也远远好于BST；  
  插入和删除操作改变树的平衡性的概率要远远小于AVL（RBT不是高度平衡的）。因此需要的旋转操作的可能性要小，而且一旦需要旋转，插入一个结点最多只需要旋转2次，删除最多只需要旋转3次(小于AVL的删除操作所需要的旋转次数)。虽然变色操作的时间复杂度在O(logN)，但是实际上，这种操作由于简单所需要的代价很小。

**4、B树（B-Tree）**

对于在内存中的查找结构而言，红黑树的效率已经非常好了。然而对于数据量非常大的查找，RBT结构显然是不实际的。像操作系统中的文件目录存储，数据库中的文件索引结构的存储.... 都不可能在内存中建立查找结构，而必须在磁盘中建立好这个结构。在磁盘中组织查找结构，从任何一个结点指向其他结点都有可能读取一次磁盘数据，再将数据写入内存进行比较。频繁的磁盘IO操作，效率是很低下的，而B树就是为了解决这个问题。

- B-Tree 的操作代价分析：

  1. 查找代价  
     B-Tree作为一个平衡多路查找树(m-叉)，其查找分成两种：一种是从一个结点查找另一结点的地址的时候，需要定位磁盘地址(查找地址)，查找代价极高。另一种是将结点中的有序关键字序列放入内存，进行优化查找(可以用折半)，相比查找代价极低。而B树的高度很小，因此在这一背景下，B树比任何二叉结构查找树的效率都要高很多。而且B+树作为B树的变种，其查找效率更高。
  2. 插入代价  
     B-Tree的插入会发生结点的分裂操作。当插入操作引起了s个节点的分裂时，磁盘访问的次数为h(读取搜索路径上的节点)＋2s(回写两个分裂出的新节点)＋1（回写新的根节点或插入后没有导致分裂的节点）。因此，所需要的磁盘访问次数是h+2s+1，最多可达到3h+1。因此插入的代价是很大的。
  3. 删除代价  
     B-Tree的删除会发生结点合并操作。最坏情况下磁盘访问次数是3h＝（找到包含被删除元素需要h次读访问）+（获取第2至h层的最相邻兄弟需要h-1次读访问）+（在第3至h层的合并需要h-2次写访问）+（对修改过的根节点和第2层的两个节点进行3次写访问）

- B-Tree效率总结 : 

  由于考虑磁盘储存结构，B树的查找、删除、插入的代价都远远要小于任何二叉结构树(读写磁盘次数的降低)。

**5、AVL和RBT的对比**

- 结构对比

  AVL的结构高度平衡，RBT的结构基本平衡。

- 查找对比

  AVL 查找时间复杂度最好、最坏情况都是O(logN)；RBT 查找时间复杂度最好为O(logN)，最坏情况下比AVL略差。

- 插入删除对比

  （1）AVL的插入和删除结点很容易造成树结构的不平衡，而RBT的平衡度要求较低。因此在大量数据插入的情况下，RBT需要通过旋转变色操作来重新达到平衡的频度要小于AVL。

  （2）如果需要平衡处理时，RBT比AVL多一种变色操作，而且变色的时间复杂度在O(logN)数量级上。但由于操作简单，实践中这种变色仍是非常快速的。

  （3）当插入一个结点都引起了树的不平衡，AVL和RBT都最多需要2次旋转操作。但删除一个结点引起不平衡后，AVL最多需要logN 次旋转操作，而RBT最多只需要3次。因此两者插入一个结点的代价差不多，但删除一个结点的代价RBT要低一些。

  （4）AVL和RBT的插入删除代价主要还是消耗在查找待操作的结点上。因此时间复杂度基本上都是与O(logN) 成正比的。

- 总体评价：RBT的总体统计性能要好于平衡二叉树

**6、B~树和B+树的对比**

- 结构对比

  B~树是平衡多路查找树，所有结点中都包含了待查关键字的有效信息(比如文件磁盘指针)。每个结点若有n个关键字，则有n+1个指向其他结点的指针。

  B+树严格意义上说已经不是树，它的叶子结点之间也有指针链接。B+树的非终结点中并不含有关键字的信息，需要查找的关键字的全部信息都包含在叶子结点上。非终结点中只作为叶子结点关键字的索引而存在。

- 查找对比

  （1）在相同数量的待查数据下，B+树查找过程中需要调用的磁盘IO操作要少于普通B~树。由于B树所在的磁盘存储背景下，因此B+树的查找性能要好于B~树。

  （2）B+树的查找效率更加稳定，因为所有叶子结点都处于同一层中，而且查找所有关键字都必须走完从根结点到叶子结点的全部历程。因此同一颗B+树中，任何关键字的查找比较次数都是一样的。而B树就不一定了，可能查找到某一个非终结点就结束了。

- 插入删除对比

   B+树与B~树在插入删除操作中的效率是差不多的

- 总体评价：在应用背景下，特别是文件结构存储中，B+树的应用要更多，其效率也要比B~树好。



参考：

[B-树 红黑树 二叉搜索树 AVL树比较](https://troywu0.gitbooks.io/spark/content/b-%E6%A0%91-%E7%BA%A2%E9%BB%91%E6%A0%91-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-avl%E6%A0%91-%E6%AF%94%E8%BE%83.html)

[面试旧敌之红黑树（直白介绍深入理解）](https://juejin.im/entry/58371f13a22b9d006882902d)（红黑树的具体内容可以参考这篇博客）

